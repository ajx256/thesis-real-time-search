#include <iostream>
#include <time.h>
#include <string>
#include <fstream>
#include <limits>
#include "../domain/TreeWorld.h"
#include "../utility/PriorityQueue.h"
#include "../RealTimeSearch.h"
#include "../utility/ResultContainer.h"
#include <unordered_map>

using namespace std;

typedef typename TreeWorld::State State;
typedef typename TreeWorld::HashState Hash;
typedef typename TreeWorld::Cost Cost;

struct Node
{
    Cost g;
    Cost h;
    Node *parent;
    State stateRep;
    bool open;

  public:
    Cost getGValue() const { return g; }
    Cost getHValue() const { return h; }
    Cost getFValue() const { return g + h; }
    State getState() const { return stateRep; }
    Node *getParent() const { return parent; }

    void setHValue(Cost val) { h = val; }
    void setGValue(Cost val) { g = val; }
    void setState(State s) { stateRep = s; }
    void setParent(Node *p) { parent = p; }

    bool onOpen() { return open; }
    void close() { open = false; }

    Node(Cost g, Cost h, State state, Node *parent)
        : g(g), h(h), stateRep(state), parent(parent)
    {
        open = true;
    }

    friend std::ostream &operator<<(std::ostream &stream, const Node &node)
    {
        stream << node.getState() << endl;
        stream << "f: " << node.getFValue() << endl;
        stream << "g: " << node.getGValue() << endl;
        stream << "h: " << node.getHValue() << endl;
        stream << "action generated by: " << node.getState().getLabel() << endl;
        stream << "-----------------------------------------------" << endl;
        stream << endl;
        return stream;
    }

    static bool compareNodesF(const Node *n1, const Node *n2)
    {
        // Tie break on g-value
        if (n1->getFValue() == n2->getFValue())
        {
            return n1->getGValue() > n2->getGValue();
        }
        return n1->getFValue() < n2->getFValue();
    }

    static bool compareNodesH(const Node *n1, const Node *n2)
    {
        if (n1->getHValue() == n2->getHValue())
        {
            return n1->getGValue() > n2->getGValue();
        }
        return n1->getHValue() < n2->getHValue();
    }
};

PriorityQueue<Node*> open;
unordered_map<State, Node*, Hash> closed;

bool aStarSearch(clock_t startTime, Node* start, TreeWorld domain)
{
    open.push(start);

    while (!open.empty())
    {
        if ((clock() - startTime) / (double) CLOCKS_PER_SEC / 60.0 >= 5)
        {
            return false;
        }

        Node* cur = open.top();
        open.pop();

        if (domain.isGoal(cur->getState()))
        {
            return true;
        }

        vector<State> successors = domain.successors(cur->getState());

        for (State child : successors)
        {
            Node* childNode = new Node(cur->getGValue() + domain.getEdgeCost(child),
					domain.heuristic(child),  child, cur);

            closed[child] = childNode;

            open.push(childNode);
        }
    }
    return false;
}

void clean()
{
    // Empty OPEN and CLOSED
	open.clear();

	// delete all of the nodes from the last expansion phase
	for (typename unordered_map<State, Node*, Hash>::iterator it = closed.begin(); it != closed.end(); it++)
		delete it->second;

	closed.clear();
}

int main()
{
    string directory = "../../worlds/treeWorld/";
    // Loop over the random tree depths being tested
    for (int depth = 10; depth <= 1000; depth++)
    {
        bool success = true;
        // We're going to try to solve the first 100 instances optimally...
        for (int instance = 1; instance <= 100; instance++)
        {
            // Get this instance of the random tree
            string file = "b2d" + to_string(depth) + "-" + to_string(instance) + ".tw";
            ifstream worldIn(directory + file); 

            // Make this instance of the TreeWorld
            TreeWorld world(worldIn);

            Node* start = new Node(0, world.heuristic(world.getStartState()), 
                                   world.getStartState(), NULL);
            closed[start->getState()] = start;
            open.swapComparator(Node::compareNodesF);

            clock_t begin = clock();

            // Try to solve the instance
            bool solved = aStarSearch(begin, start, world);

            clean();
            
            //RealTimeSearch<TreeWorld> minimin(world, "dfs", "none", "k-best", 29, numeric_limits<double>::infinity(), "normal");

            //ResultContainer res = minimin.search();
            //bool solved = res.solutionFound;

            if (!solved)
            {
                success = false;
                break;
            }
        }

        if (success)
            cout << "depth " << depth << " solved!" << endl; 
        else
            cout << "depth " << depth << " failed" << endl; 
    }
}